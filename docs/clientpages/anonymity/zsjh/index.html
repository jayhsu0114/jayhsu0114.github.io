<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>中山匿名網頁</title>
    <link rel="stylesheet" href="style.css"> <!-- 引入外部的 CSS 文件路径 -->
    <script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-2383721687553257" crossorigin="anonymous"></script>
</head>
<body>
    <canvas id="gravityCanvas"></canvas>
    <div class="container">
        <h1>中山匿名網頁</h1>
        <form id="zsjhForm">
            <label for="anonymousContent">匿名內容</label>
            <textarea id="anonymousContent" name="anonymousContent" required></textarea>
            <input type="hidden" id="userIP" name="userIP">
            <input type="hidden" id="formId" name="formId" value="zsjh">
            <button type="submit" id="submitButton">提交</button>
        </form>
    </div>

    <script>
        let isSubmitted = false;

        async function getUserIP() {
            try {
                const response = await fetch('https://api.ipify.org?format=json');
                const data = await response.json();
                return data.ip;
            } catch (error) {
                console.error('獲取使用者IP地址失敗:', error);
                return 'unknown';
            }
        }

        document.getElementById('zsjhForm').addEventListener('submit', async function(event) {
            event.preventDefault();
            
            if (isSubmitted) {
                alert('表單已經提交，請稍候再試。');
                return;
            }
            
            isSubmitted = true;
            document.getElementById('submitButton').disabled = true;

            const ip = await getUserIP();
            document.getElementById('userIP').value = ip;

            const formData = new FormData(this);
            fetch('https://script.google.com/macros/s/AKfycbwC_5HrfS_D8d5QiWnAzga5NYJpYZHjP9jOeE-QJz0_VgayXva7Ss4Nl62atsWaQvmR/exec', {
                method: 'POST',
                body: formData
            })
            .then(response => response.json())
            .then(data => {
                alert('提交成功！');
                this.reset();
                document.getElementById('submitButton').disabled = false;
                isSubmitted = false;
            })
            .catch(error => {
                console.error('提交失敗:', error);
                alert('提交失敗，請稍候再試。');
                document.getElementById('submitButton').disabled = false;
                isSubmitted = false;
            });
        });

        document.getElementById('anonymousContent').addEventListener('keydown', function(event) {
            if (event.key === 'Enter') {
                event.preventDefault();
                this.value += '\n';
            }
        });

        // 以下是模擬重力和碰撞的腳本
        const canvas = document.getElementById('gravityCanvas');
        const ctx = canvas.getContext('2d');
        const colors = ['#70a7dd', '#de6768'];
        const balls = [];
        const numBalls = 20;
        const gravity = 0.1;  // 降低重力值
        const friction = 0.98;

        function resizeCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
        }

        window.addEventListener('resize', resizeCanvas);
        resizeCanvas();

        class Ball {
            constructor(x, y, dx, dy, radius, color) {
                this.x = x;
                this.y = y;
                this.dx = dx;
                this.dy = dy;
                this.radius = radius;
                this.color = color;
            }

            draw() {
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.radius, 0, Math.PI * 2, false);
                ctx.fillStyle = this.color;
                ctx.fill();
                ctx.closePath();
            }

            update() {
                if (this.y + this.radius + this.dy > canvas.height) {
                    this.dy = -this.dy * friction;
                } else {
                    this.dy += gravity;
                }

                if (this.x + this.radius + this.dx > canvas.width || this.x - this.radius + this.dx < 0) {
                    this.dx = -this.dx;
                }

                this.x += this.dx;
                this.y += this.dy;
                this.draw();
            }
        }

        function init() {
            balls.length = 0;
            for (let i = 0; i < numBalls; i++) {
                const radius = 20;
                const x = Math.random() * (canvas.width - radius * 2) + radius;
                const y = Math.random() * (canvas.height - radius * 2) + radius;
                const dx = (Math.random() - 0.5) * 1;  // 降低初始速度
                const dy = (Math.random() - 0.5) * 1;  // 降低初始速度
                const color = colors[Math.floor(Math.random() * colors.length)];
                balls.push(new Ball(x, y, dx, dy, radius, color));
            }
        }

        function animate() {
            requestAnimationFrame(animate);
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            balls.forEach(ball => ball.update());
            checkCollisions();
        }

        function checkCollisions() {
            for (let i = 0; i < balls.length; i++) {
                for (let j = i + 1; j < balls.length; j++) {
                    const dx = balls[i].x - balls[j].x;
                    const dy = balls[i].y - balls[j].y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance < balls[i].radius + balls[j].radius) {
                        resolveCollision(balls[i], balls[j]);
                    }
                }
            }
        }

        function resolveCollision(ball1, ball2) {
            const xVelocityDiff = ball1.dx - ball2.dx;
            const yVelocityDiff = ball1.dy - ball2.dy;
            const xDist = ball2.x - ball1.x;
            const yDist = ball2.y - ball1.y;

            if (xVelocityDiff * xDist + yVelocityDiff * yDist >= 0) {
                const angle = -Math.atan2(ball2.y - ball1.y, ball2.x - ball1.x);

                const m1 = ball1.radius;
                const m2 = ball2.radius;

                const u1 = rotate(ball1.dx, ball1.dy, angle);
                const u2 = rotate(ball2.dx, ball2.dy, angle);

                const v1 = { x: u1.x * (m1 - m2) / (m1 + m2) + u2.x * 2 * m2 / (m1 + m2), y: u1.y };
                const v2 = { x: u2.x * (m1 - m2) / (m1 + m2) + u1.x * 2 * m1 / (m1 + m2), y: u2.y };

                const vFinal1 = rotate(v1.x, v1.y, -angle);
                const vFinal2 = rotate(v2.x, v2.y, -angle);

                ball1.dx = vFinal1.x;
                ball1.dy = vFinal1.y;

                ball2.dx = vFinal2.x;
                ball2.dy = vFinal2.y;
            }
        }

        function rotate(dx, dy, angle) {
            return {
                x: dx * Math.cos(angle) - dy * Math.sin(angle),
                y: dx * Math.sin(angle) + dy * Math.cos(angle)
            };
        }

        window.addEventListener('devicemotion', (event) => {
            const ax = event.accelerationIncludingGravity.x;
            const ay = event.accelerationIncludingGravity.y;
            balls.forEach(ball => {
                ball.dx += ax * 0.05;  // 降低加速度影響
                ball.dy += ay * 0.05;  // 降低加速度影響
            });
        });

        init();
        animate();
    </script>
</body>
</html>
